# Monad

1. `bind : m α → (α → m β) → m β` 分为两部
    1. 调用 `next` 前：将 `opt : m α` 提取出 `x : α`
    2. 调用 `next` 后：将 `next x : m β` 处理为另一个 `m β` 的元素

    未调用 `next` 的分支不会执行后续语句

2. 对简单区块的分析：下述 `E` 可能含有后续 `bind`，因此可以推广到一般情景

    ```lean
    E₁ >>= fun₁ x₁ =>
      E₂ >>= fun₂ x₂ =>
        E
    
    E₁ : m₁ α₁
    x₁ : α₁
    
    E₂ : m₂ α₂
    x₂ : α₂
    
    E  : m  β
    ```

    1. 调用顺序：`fun₁` 的前处理 → `fun₂` 的前处理 → 返回 `E` → `fun₂` 的后处理 → `fun₁` 的后处理
    2. 记 `E₂ >>= fun x₂ => E` 为 `B₂ : m₂ β₂`，`E₁ >>= fun x₁ => B₂` 为 `B₁ : m₁ β₁`
        1. `fun₁` 的前处理暗示若 `x₁` 为 `()`，则 `E₁` 的类型必然为 `m Unit`
        2. `fun₂` 的后处理暗示 `E` 与 `B₂` 类型相同，因此 `m = m₂, β = β₂`
        3. `fun₁` 的后处理暗示 `B₂` 与 `B₁` 类型相同，因此 `m = m₂ = m₁, β = β₂ = β₁`
        4. 即使 `α₁` 与 `α₂` 各不相同，所有函数的返回值类型相同，均为 `m β`；`do` 语句块返回值与 `E` 类型必然相同

3. `Monad` 在 `do` 语句块下的转化：假设有 `do` 语句块

    ```lean
    do E₁
      E₂
      ⋯
      Eₙ
      E
    ```

    忽略不本质的 `let x:= E`，转化得到

    ```lean
    E₁ >>= fun x₁ =>
      E₂ >>= fun x₂ =>
        ⋯
          Eₙ >>= fun xₙ =>
            E
    ```

    类型标注为

    ```lean
    E₁ : m α₁
    E₂ : m α₂
    ⋯
    Eₙ : m αₙ
    E  : m β
    ```

    1. `xᵢ` 是 `αᵢ` 元素或 `()` 的简记
    2. 所有 `m` 必须相同
    3. `α₁, α₂, ⋯, αₙ, β` 可各不相同

4. 副作用：`bind` 函数定义的内容，假设执行主体为 `do` 的 `main` 函数
    1. 为了获得最后 `main` 的返回值，需要执行前面所有 `bind`，从而产生副作用
    2. 返回得到 `IO Unit` 元素没有意义，起作用的只是中间的副作用过程
    3. 副作用实质上靠 Lean RTS 执行原语而得以可能，Lean 本身仅对 IO 活动原语进行描述
